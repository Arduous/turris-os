--- a/net/mac80211/key.c
+++ b/net/mac80211/key.c
@@ -617,10 +617,11 @@ int ieee80211_key_link(struct ieee80211_

 	pairwise = key->conf.flags & IEEE80211_KEY_FLAG_PAIRWISE;
 	idx = key->conf.keyidx;
+	/*
 	key->local = sdata->local;
 	key->sdata = sdata;
 	key->sta = sta;
-
+	*/
 	mutex_lock(&sdata->local->key_mtx);

 	if (sta && pairwise)
@@ -630,6 +631,22 @@ int ieee80211_key_link(struct ieee80211_
 	else
 		old_key = key_mtx_dereference(sdata->local, sdata->keys[idx]);

+
+	/*
+	 * Silently accept key re-installation without really installing the
+	 * new version of the key to avoid nonce reuse or replay issues.
+	 */
+	if (old_key && key->conf.keylen == old_key->conf.keylen &&
+	    !memcmp(key->conf.key, old_key->conf.key, key->conf.keylen)) {
+		ieee80211_key_free_unused(key);
+		ret = 0;
+		goto out;
+	}
+
+	key->local = sdata->local;
+	key->sdata = sdata;
+	key->sta = sta;
+
 	increment_tailroom_need_count(sdata);

 	ieee80211_key_replace(sdata, sta, pairwise, old_key, key);
@@ -644,7 +661,7 @@ int ieee80211_key_link(struct ieee80211_
 	} else {
 		ret = 0;
 	}
-
+out:
 	mutex_unlock(&sdata->local->key_mtx);

 	return ret;
